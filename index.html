<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoself Systems - Emergent Assembly</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
        }
        
        canvas {
            display: block;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff41;
            font-size: 10px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">ASSEMBLING...</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const info = document.getElementById('info');
        
        updateCanvasSize();
        
        // Color palette
        const PALETTE = {
            matrixGreen: '#00ff41', // Matrix green for boids when not carrying
            trailWithPixel: '#ffffff',
            trailEmpty: 'rgba(0, 255, 65, 0.2)',
            textPixel: '#ffffff',
            infinityPixel: '#ffffff' // Changed to white
        };
        
        // Font definition for pixel art
        const PIXEL_SIZE = 3;
        const LETTER_SPACING = 1;
        const WORD_SPACING = 3;
        const LINE_SPACING = 2;

        const TEXT_LINES = [
            { text: "EXOSELF", offsetY: -15 },
            { text: "SYSTEMS", offsetY: 5 }
        ];
        
        const FONT = {
            'E': [
                [1,1,1,1],
                [1,0,0,0],
                [1,1,1,0],
                [1,0,0,0],
                [1,1,1,1]
            ],
            'X': [
                [1,0,0,1],
                [1,0,0,1],
                [0,1,1,0],
                [1,0,0,1],
                [1,0,0,1]
            ],
            'O': [
                [0,1,1,0],
                [1,0,0,1],
                [1,0,0,1],
                [1,0,0,1],
                [0,1,1,0]
            ],
            'S': [
                [0,1,1,1],
                [1,0,0,0],
                [0,1,1,0],
                [0,0,0,1],
                [1,1,1,0]
            ],
            'E2': [
                [1,1,1,1],
                [1,0,0,0],
                [1,1,1,0],
                [1,0,0,0],
                [1,1,1,1]
            ],
            'L': [
                [1,0,0,0],
                [1,0,0,0],
                [1,0,0,0],
                [1,0,0,0],
                [1,1,1,1]
            ],
            'F': [
                [1,1,1,1],
                [1,0,0,0],
                [1,1,1,0],
                [1,0,0,0],
                [1,0,0,0]
            ],
            'Y': [
                [1,0,0,1],
                [1,0,0,1],
                [0,1,1,0],
                [0,1,0,0],
                [0,1,0,0]
            ],
            'T': [
                [1,1,1,1,1],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0],
                [0,0,1,0,0]
            ],
            'M': [
                [1,0,0,0,1],
                [1,1,0,1,1],
                [1,0,1,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1]
            ]
        };

        function updateCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function measureTextLine(text) {
            let width = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const key = char === 'E' && i > 0 ? 'E2' : char;
                const letter = FONT[key] || FONT['E'];
                width += letter[0].length * PIXEL_SIZE + LETTER_SPACING * PIXEL_SIZE;
            }
            return width;
        }

        function computeLayout() {
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const sceneCenterY = height / 2;
            const textCenterY = sceneCenterY + 30;
            const infinityScale = Math.max(20, Math.min(30, Math.min(width, height) * 0.04));
            const textMetrics = TEXT_LINES.map((line, index) => {
                const lineWidth = measureTextLine(line.text);
                return {
                    text: line.text,
                    startX: centerX - lineWidth / 2,
                    baseY: textCenterY + line.offsetY,
                    index
                };
            });

            return {
                width,
                height,
                centerX,
                sceneCenterY,
                infinityCenterY: sceneCenterY - 50,
                infinityScale,
                textMetrics
            };
        }

        function buildTextBlueprint() {
            const blueprint = [];
            let pixelId = 0;

            TEXT_LINES.forEach((line, lineIndex) => {
                let currentOffsetX = 0;
                for (let i = 0; i < line.text.length; i++) {
                    const char = line.text[i];
                    const key = char === 'E' && i > 0 ? 'E2' : char;
                    const letter = FONT[key] || FONT['E'];

                    for (let y = 0; y < letter.length; y++) {
                        for (let x = 0; x < letter[y].length; x++) {
                            if (letter[y][x] === 1) {
                                blueprint.push({
                                    id: `text_${pixelId++}`,
                                    kind: 'text',
                                    lineIndex,
                                    offsetX: currentOffsetX + x * PIXEL_SIZE,
                                    offsetY: y * PIXEL_SIZE,
                                    color: PALETTE.textPixel
                                });
                            }
                        }
                    }

                    currentOffsetX += letter[0].length * PIXEL_SIZE + LETTER_SPACING * PIXEL_SIZE;
                }
            });

            return blueprint;
        }

        // Infinity symbol pixels and attractor
        let infinityPixels = [];
        let infinityBlueprint = [];
        const infinityAttractor = {
            x: 0,
            y: 0,
            t: 0, // Parameter for position along the curve
            speed: 0.01,
            active: false,
            velocity: { x: 0, y: 0 }
        };

        let textBlueprint = [];
        let textPixels = [];
        let layout = null;
        let previousLayout = null;
        let allPixels = [];
        let placedCount = 0;
        let frame = 0;
        let assemblyComplete = false;
        
        function buildInfinityBlueprint(currentLayout) {
            const { centerX, infinityCenterY, infinityScale } = currentLayout;
            const positions = new Map();
            let id = 0;

            const scale = infinityScale;
            const steps = 100;

            function addPosition(x, y) {
                const key = `${x},${y}`;
                if (!positions.has(key)) {
                    positions.set(key, {
                        id: `inf_${id++}`,
                        kind: 'infinity',
                        normalizedX: (x - centerX) / scale,
                        normalizedY: (y - infinityCenterY) / scale,
                        color: PALETTE.infinityPixel
                    });
                }
            }

            for (let i = 0; i < steps; i++) {
                const t = (i / steps) * 2 * Math.PI;
                const x = scale * 2 * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                const y = scale * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                const pixX = Math.round(centerX + x);
                const pixY = Math.round(infinityCenterY + y);
                addPosition(pixX, pixY);

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        addPosition(pixX + dx * 2, pixY + dy * 2);
                    }
                }
            }

            for (let pass = 0; pass < 3; pass++) {
                const offset = pass * 0.1;
                for (let i = 0; i < steps; i++) {
                    const t = (i / steps) * 2 * Math.PI + offset;
                    const scales = [
                        { sx: 1.9, sy: 0.95 },
                        { sx: 2.0, sy: 1.0 },
                        { sx: 2.1, sy: 1.05 }
                    ];

                    for (let s of scales) {
                        const x = scale * s.sx * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                        const y = scale * s.sy * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                        const pixX = Math.round(centerX + x);
                        const pixY = Math.round(infinityCenterY + y);
                        addPosition(pixX, pixY);

                        if (i > 0) {
                            const prevT = ((i - 1) / steps) * 2 * Math.PI + offset;
                            const prevX = scale * s.sx * Math.cos(prevT) / (1 + Math.sin(prevT) * Math.sin(prevT));
                            const prevY = scale * s.sy * Math.sin(prevT) * Math.cos(prevT) / (1 + Math.sin(prevT) * Math.sin(prevT));
                            const prevPixX = Math.round(centerX + prevX);
                            const prevPixY = Math.round(infinityCenterY + prevY);

                            const interpSteps = 3;
                            for (let j = 1; j < interpSteps; j++) {
                                const interpX = Math.round(prevPixX + (pixX - prevPixX) * j / interpSteps);
                                const interpY = Math.round(prevPixY + (pixY - prevPixY) * j / interpSteps);
                                addPosition(interpX, interpY);
                            }
                        }
                    }
                }
            }

            return Array.from(positions.values());
        }
        
        function updateInfinityAttractor() {
            if (!infinityAttractor.active) return;

            const prevX = infinityAttractor.x;
            const prevY = infinityAttractor.y;

            infinityAttractor.t += infinityAttractor.speed;
            if (infinityAttractor.t > 2 * Math.PI) {
                infinityAttractor.t -= 2 * Math.PI;
            }

            refreshInfinityAttractorPosition(layout);

            infinityAttractor.velocity.x = infinityAttractor.x - prevX;
            infinityAttractor.velocity.y = infinityAttractor.y - prevY;
            const vx = infinityAttractor.velocity.x;
            const vy = infinityAttractor.velocity.y;
            infinityAttractor.velocity.magnitude = Math.sqrt(vx * vx + vy * vy);
        }
        
        function instantiatePixels(blueprint) {
            return blueprint.map(item => {
                const pixel = {
                    id: item.id,
                    blueprint: item,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    targetX: 0,
                    targetY: 0,
                    renderX: undefined,
                    renderY: undefined,
                    placed: false,
                    carried: false,
                    color: item.color,
                    isInfinity: item.kind === 'infinity'
                };
                return pixel;
            });
        }

        function assignTargetsForPixels(pixels, currentLayout) {
            for (let pixel of pixels) {
                if (pixel.blueprint.kind === 'infinity') {
                    pixel.targetX = currentLayout.centerX + pixel.blueprint.normalizedX * currentLayout.infinityScale;
                    pixel.targetY = currentLayout.infinityCenterY + pixel.blueprint.normalizedY * currentLayout.infinityScale;
                } else if (pixel.blueprint.kind === 'text') {
                    const lineMetrics = currentLayout.textMetrics[pixel.blueprint.lineIndex];
                    pixel.targetX = lineMetrics.startX + pixel.blueprint.offsetX;
                    pixel.targetY = lineMetrics.baseY + pixel.blueprint.offsetY;
                }

                if (pixel.renderX === undefined || pixel.renderY === undefined) {
                    pixel.renderX = pixel.targetX;
                    pixel.renderY = pixel.targetY;
                }

                if (pixel.placed) {
                    pixel.x = pixel.targetX;
                    pixel.y = pixel.targetY;
                }
            }
        }
        
        // Boid class
        class Boid {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.maxSpeed = 2 + Math.random() * 2;
                this.baseMaxSpeed = this.maxSpeed;
                this.maxForce = 0.05 + Math.random() * 0.05;
                
                // Randomized flocking parameters
                this.separationWeight = 0.5 + Math.random() * 1.5;
                this.alignmentWeight = 0.5 + Math.random() * 1.5;
                this.cohesionWeight = 0.5 + Math.random() * 1.5;
                
                this.perceptionRadius = 30 + Math.random() * 50;
                this.separationRadius = 15 + Math.random() * 15;
                
                this.carryingPixel = null;
                this.trail = [];
                this.maxTrailLength = 20;
                
                this.size = 3;
                this.color = PALETTE.matrixGreen; // All boids are Matrix green
            }
            
            flock(boids) {
                let separation = this.separate(boids);
                let alignment = this.align(boids);
                let cohesion = this.cohere(boids);
                
                separation.mult(this.separationWeight);
                alignment.mult(this.alignmentWeight);
                cohesion.mult(this.cohesionWeight);
                
                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
                
                // Add infinity attractor force if active
                if (infinityAttractor.active && !this.carryingPixel) {
                    let attractorForce = this.seek(infinityAttractor.x, infinityAttractor.y);
                    attractorForce.mult(2); // 2x more powerful than other forces
                    this.applyForce(attractorForce);
                }
            }
            
            separate(boids) {
                let steer = new Vector(0, 0);
                let count = 0;
                
                for (let boid of boids) {
                    let d = distance(this.x, this.y, boid.x, boid.y);
                    if (d > 0 && d < this.separationRadius) {
                        let diff = new Vector(this.x - boid.x, this.y - boid.y);
                        diff.normalize();
                        diff.div(d);
                        steer.add(diff);
                        count++;
                    }
                }
                
                if (count > 0) {
                    steer.div(count);
                    steer.normalize();
                    steer.mult(this.maxSpeed);
                    steer.sub(new Vector(this.vx, this.vy));
                    steer.limit(this.maxForce);
                }
                
                return steer;
            }
            
            align(boids) {
                let sum = new Vector(0, 0);
                let count = 0;
                
                for (let boid of boids) {
                    let d = distance(this.x, this.y, boid.x, boid.y);
                    if (d > 0 && d < this.perceptionRadius) {
                        sum.add(new Vector(boid.vx, boid.vy));
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(this.maxSpeed);
                    let steer = sum.sub(new Vector(this.vx, this.vy));
                    steer.limit(this.maxForce);
                    return steer;
                }
                
                return new Vector(0, 0);
            }
            
            cohere(boids) {
                let sum = new Vector(0, 0);
                let count = 0;
                
                for (let boid of boids) {
                    let d = distance(this.x, this.y, boid.x, boid.y);
                    if (d > 0 && d < this.perceptionRadius) {
                        sum.add(new Vector(boid.x, boid.y));
                        count++;
                    }
                }
                
                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum.x, sum.y);
                }
                
                return new Vector(0, 0);
            }
            
            seek(targetX, targetY) {
                let desired = new Vector(targetX - this.x, targetY - this.y);
                desired.normalize();
                desired.mult(this.maxSpeed);
                let steer = desired.sub(new Vector(this.vx, this.vy));
                steer.limit(this.maxForce);
                return steer;
            }
            
            applyForce(force) {
                this.vx += force.x;
                this.vy += force.y;
            }
            
            checkPixelCollision(pixels) {
                if (!this.carryingPixel) {
                    for (let pixel of pixels) {
                        if (!pixel.carried && !pixel.placed) {
                            let d = distance(this.x, this.y, pixel.x, pixel.y);
                            if (d < 10) {
                                this.carryingPixel = pixel;
                                pixel.carried = true;
                                return;
                            }
                        }
                    }
                }
            }
            
            update(pixels) {
                // Store previous position for teleport detection
                const prevX = this.x;
                const prevY = this.y;
                
                // If carrying a pixel, move toward its target
                if (this.carryingPixel) {
                    let targetForce = this.seek(this.carryingPixel.targetX, this.carryingPixel.targetY);
                    targetForce.mult(3); // Strong attraction to target
                    this.applyForce(targetForce);
                    
                    // Update pixel position
                    this.carryingPixel.x = this.x;
                    this.carryingPixel.y = this.y;
                    
                    // Check if reached target
                    let d = distance(this.x, this.y, this.carryingPixel.targetX, this.carryingPixel.targetY);
                    if (d < 5) {
                        this.carryingPixel.x = this.carryingPixel.targetX;
                        this.carryingPixel.y = this.carryingPixel.targetY;
                        this.carryingPixel.placed = true;
                        this.carryingPixel.carried = false;
                        this.carryingPixel.renderX = this.carryingPixel.targetX;
                        this.carryingPixel.renderY = this.carryingPixel.targetY;
                        this.carryingPixel = null;
                    }
                }
                
                // Limit speed
                let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Wrap around edges and detect teleportation
                let teleported = false;
                if (this.x < 0) {
                    this.x = canvas.width;
                    teleported = true;
                }
                if (this.x > canvas.width) {
                    this.x = 0;
                    teleported = true;
                }
                if (this.y < 0) {
                    this.y = canvas.height;
                    teleported = true;
                }
                if (this.y > canvas.height) {
                    this.y = 0;
                    teleported = true;
                }
                
                // Update trail (clear it if teleported to prevent streaks)
                if (teleported) {
                    this.trail = []; // Clear trail on teleport
                } else {
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
            }
            
            draw(ctx) {
                // Draw trail only if we have more than one point and didn't just teleport
                if (this.trail.length > 1) {
                    ctx.strokeStyle = this.carryingPixel ? PALETTE.trailWithPixel : PALETTE.trailEmpty;
                    ctx.lineWidth = this.carryingPixel ? 2 : 1;
                    ctx.globalAlpha = this.carryingPixel ? 0.6 : 0.2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    
                    // Check for large jumps in trail (another teleport check)
                    let lastPoint = this.trail[0];
                    for (let i = 1; i < this.trail.length; i++) {
                        let point = this.trail[i];
                        let dist = distance(lastPoint.x, lastPoint.y, point.x, point.y);
                        
                        // If distance is too large, it's a teleport - start new path
                        if (dist > 50) {
                            ctx.moveTo(point.x, point.y);
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                        lastPoint = point;
                    }
                    
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // Draw boid
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                
                if (this.carryingPixel) {
                    ctx.fillStyle = this.carryingPixel.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.carryingPixel.color;
                } else {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = this.color;
                }
                
                ctx.beginPath();
                ctx.moveTo(this.size, 0);
                ctx.lineTo(-this.size, -this.size/2);
                ctx.lineTo(-this.size, this.size/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Vector helper class
        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }
            
            sub(v) {
                this.x -= v.x;
                this.y -= v.y;
                return this;
            }
            
            mult(n) {
                this.x *= n;
                this.y *= n;
                return this;
            }
            
            div(n) {
                this.x /= n;
                this.y /= n;
                return this;
            }
            
            normalize() {
                let mag = Math.sqrt(this.x * this.x + this.y * this.y);
                if (mag > 0) {
                    this.div(mag);
                }
                return this;
            }
            
            limit(max) {
                let mag = Math.sqrt(this.x * this.x + this.y * this.y);
                if (mag > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
        }
        
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
        
        function refreshInfinityAttractorPosition(currentLayout) {
            const { centerX, infinityCenterY, infinityScale } = currentLayout;
            const t = infinityAttractor.t;
            const denominator = 1 + Math.sin(t) * Math.sin(t);
            const x = infinityScale * 2 * Math.cos(t) / denominator;
            const y = infinityScale * Math.sin(t) * Math.cos(t) / denominator;
            infinityAttractor.x = centerX + x;
            infinityAttractor.y = infinityCenterY + y;
        }

        function initializeScene() {
            updateCanvasSize();
            layout = computeLayout();
            textBlueprint = buildTextBlueprint();
            infinityBlueprint = buildInfinityBlueprint(layout);
            infinityPixels = instantiatePixels(infinityBlueprint);
            textPixels = instantiatePixels(textBlueprint);
            allPixels = [...infinityPixels, ...textPixels];
            assignTargetsForPixels(allPixels, layout);
            previousLayout = { ...layout };
            refreshInfinityAttractorPosition(layout);
        }

        initializeScene();

        function handleResize() {
            const prevLayout = layout ? { ...layout } : null;

            updateCanvasSize();
            layout = computeLayout();
            assignTargetsForPixels(allPixels, layout);

            if (prevLayout) {
                const widthRatio = prevLayout.width ? layout.width / prevLayout.width : 1;
                const heightRatio = prevLayout.height ? layout.height / prevLayout.height : 1;

                allPixels.forEach(pixel => {
                    if (!pixel.placed && !pixel.carried) {
                        pixel.x *= widthRatio;
                        pixel.y *= heightRatio;
                        pixel.x = Math.max(0, Math.min(layout.width, pixel.x));
                        pixel.y = Math.max(0, Math.min(layout.height, pixel.y));
                    }
                });

                boids.forEach(boid => {
                    boid.x *= widthRatio;
                    boid.y *= heightRatio;
                    boid.x = Math.max(0, Math.min(layout.width, boid.x));
                    boid.y = Math.max(0, Math.min(layout.height, boid.y));
                    boid.trail = boid.trail.map(point => ({
                        x: point.x * widthRatio,
                        y: point.y * heightRatio
                    }));

                    if (boid.carryingPixel) {
                        boid.carryingPixel.x = boid.x;
                        boid.carryingPixel.y = boid.y;
                    }
                });
            }

            refreshInfinityAttractorPosition(layout);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (assemblyComplete) {
                const estimated = infinityAttractor.velocity.magnitude !== undefined
                    ? infinityAttractor.velocity.magnitude
                    : infinityAttractor.speed * layout.infinityScale * 0.5;
                const attractorSpeed = Math.min(Math.max(estimated, 0.4), 6);
                boids.forEach(boid => {
                    boid.maxSpeed = attractorSpeed;
                });
            }
            previousLayout = { ...layout };
        }
        
        const boids = [];
        const NUM_BOIDS = 80;
        
        for (let i = 0; i < NUM_BOIDS; i++) {
            boids.push(new Boid(
                Math.random() * canvas.width,
                Math.random() * canvas.height
            ));
        }
        // Animation loop
        function animate() {
            // Fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update infinity attractor position
            updateInfinityAttractor();

            if (assemblyComplete && infinityAttractor.velocity.magnitude !== undefined) {
                const attractorSpeed = Math.min(Math.max(infinityAttractor.velocity.magnitude, 0.4), 6);
                for (let boid of boids) {
                    boid.maxSpeed = attractorSpeed;
                }
            }
            
            // Update and draw all pixels
            ctx.shadowBlur = 0;
            for (let pixel of allPixels) {
                if (!pixel.carried) {
                    if (pixel.placed) {
                        pixel.renderX += (pixel.targetX - pixel.renderX) * 0.12;
                        pixel.renderY += (pixel.targetY - pixel.renderY) * 0.12;

                        ctx.fillStyle = pixel.color;
                        ctx.fillRect(pixel.renderX - PIXEL_SIZE / 2, pixel.renderY - PIXEL_SIZE / 2, PIXEL_SIZE, PIXEL_SIZE);

                        if (Math.random() < 0.01) {
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = pixel.color;
                            ctx.fillRect(pixel.renderX - PIXEL_SIZE / 2, pixel.renderY - PIXEL_SIZE / 2, PIXEL_SIZE, PIXEL_SIZE);
                            ctx.shadowBlur = 0;
                        }
                    } else {
                        ctx.fillStyle = pixel.color;
                        ctx.globalAlpha = 0.3 + Math.sin(frame * 0.05 + pixel.x) * 0.2;
                        ctx.fillRect(pixel.x - 1, pixel.y - 1, 2, 2);
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            // Update and draw boids
            for (let boid of boids) {
                boid.flock(boids);
                boid.checkPixelCollision(allPixels);
                boid.update(allPixels);
                boid.draw(ctx);
            }
            
            // Count placed pixels
            let currentPlaced = allPixels.filter(p => p.placed).length;
            if (currentPlaced !== placedCount) {
                placedCount = currentPlaced;
                let progress = Math.floor((placedCount / allPixels.length) * 100);
                
                if (progress >= 100 && !assemblyComplete) {
                    assemblyComplete = true;
                    infinityAttractor.active = true; // Activate the infinity attractor
                    info.textContent = 'EXOSELF SYSTEMS';
                    info.style.opacity = 1;
                    info.style.color = '#ffffff';
                } else if (progress < 100) {
                    info.textContent = `ASSEMBLING... ${progress}%`;
                }
            }
            
            frame++;
            requestAnimationFrame(animate);
        }
        
        // Handle resize
        let resizeTimer = null;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                handleResize();
            }, 150);
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>
